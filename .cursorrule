运行指令：
windows不能用 && 执行多个命令！！
有时候执行命令没反应，是因为cursor出bug了，停止执行等我下一步命令

tele_framework：
我们重新设计了framework机制, 让module资源变成一种动态访问的模式；
- 首先所有模块坑定是用户调用framework宏定义的，因此编译期就会形成一个modules顺序，通过宏可以累加各个modules大小，计算出module内存偏移
  这个编译期索引用于在framework数据结构中找到对应module的数据结构
  同时宏也会直接生成p2p module的获取函数，通过size累加和偏移计算，获取到module的内存地址
- framework应该具备一个用vec维护的modules内存片段
- 比如说，p2p基于framework，但是是一个中间层,p2p 先初始化到连续内存上
- 然后用户又定义了业务逻辑module，根据声明顺序随后初始化
这样实现的好处是，中间层逻辑无需关心后面的内存初始化，因为对他自己代码来说vector是个通用结构；而非具体类型
framework项目测试不应该依赖外部模块
framework 维护一片vec内存用于存储modules
modules 要约束实现Sync和Send
module声明时要写宏 define_module, 这个宏会一起生成模块的View
module不可以实现clone 和debug trait，如果有包含module的引用但是要实现debug，就手动实现
module offset是由宏展开时计算的，外部不要想着去用它；因为只是为framework内部服务的
view 实现应该随define_module一起生成
view 应该持有framework的weak dyn trait指针，在view初始化时，需要传入framework的借用
view 用于获取framework_def 定义的 某个模块名对应的函数，通过unsafe转换可以得到模块的不可变借用
view 的 功能是 对view对应trait的实现，由 define_framework 宏定义
define_framework会定义 module的 access trait，view，  宏的参数为 模块名和模块类型 列表，和view的函数一一对应
宏展开的过程中，通过paste还有展开时的递归，构建每个module size常量以及module前面module size求和，以作为偏移

#p2p 这一块参照原版 waverless m_p2p.rs responser对用户来说不应该是创建的，而是handler回调函数传入的参数
基于 framework的各个模块项目：

对所有项目通用的规则：
- 每个项目的result都用自己的，而不是用一个集中的；避免相互依赖
- debug 能用的情况下不要实现display
- 想要进闭包或新的任务(future async {} 其实也类似闭包)访问Module，需要用view的clone
  而 view 从哪里来，是在init时传入的，可以将其保存到module结构体下


tele_p2p：
这一块参照原版m_p2p.rs和m_p2p_quic.rs, 将原版框架模式对接成 tele_framework 的框架模式
  p2p 里面以及有了p2p自己的view，意味着framework类型已确定；但事实是framework类型是不定的；对p2p来说，他应该只约束里面东西实现了获取p2p借用这个trait； 
  所以view的持有的framework应该是个trait，也在view宏定义生成；
p2p 维护集群节点分布，持有NodesConfig
result使用p2p自己的result
RPCResponsor 和 RPCCaller 应该是 struct，而不是 trait, 并且带有数据包泛型
请求和响应通过关联类型绑定
MsgPack应该约束Default+Sized接口
